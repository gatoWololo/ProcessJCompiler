Info() ::= <<
 This file contains all templates for the ProcessJ compiler based on the grammar of
 ProcessJ. The CodeGeneratorC.java file then uses these rules as well as a visitor
 to generate our C equivalent code.
>>


Compilation(pragmas, packageName, imports, typeDecls, prototypes, parBlockPrototypes,
  parBlockProcs, functionToCall, stackSize, hasArray) ::= <<
<! TODO pragmas, packageName, imports !>
#include \<stdio.h>
#include \<cif.h>
#include \<stdbool.h>

<CommentBar()>
<if(hasArray)>
#define MAX(X, Y) ((X) > (Y) ? (X) : (Y))
<ArrayStruct()>
<CommentBar()>
<endif>


<CommentBar()>
<if(prototypes)><prototypes; separator = ";\n">;<endif>
<if(parBlockPrototypes)><\\>
<CommentBar()>
/*These functions were auto-generated by the compiler from ParBlock declarations: */
<parBlockPrototypes; separator = ";\n">;
<endif>
<CommentBar()>
<CMainFunction(functionToCall, stackSize)>
<CommentBar()>
<typeDecls;
 separator ="\n/*========================================================================================*/\n">
<! These are the actual functions generated by our ParBlock !>
<if(parBlockProcs)><\\>
<CommentBar()>
/*These functions were auto-generated by the compiler from ParBlock declarations: */
<CommentBar()>
<parBlockProcs;
 separator ="\n/*========================================================================================*/\n">
<CommentBar()>
<endif>
>>


Assignment(left, right, op) ::= <<
(<left> <op> <right>)
>>

BinaryExpr(left, right, op) ::= "(<left> <op> <right>)"


BreakStat() ::= "break"


ChannelWriteStat(globalWsName, channel, expr) ::= <<
ChanOutInt(<globalWsName>, <channel>, <expr>)
>>


ChannelReadExprInt(globalWsName, channel) ::= <<
({ int tempReadVar;
   ChanInInt(<globalWsName>, <channel>, &tempReadVar);
   tempReadVar;
})
>>


ChannelReadExprTimer(globalWsName, channel) ::= <<
TimerRead(<globalWsName>)
>>


TimeoutStat(globalWsName, delay) ::= <<
TimerDelay(<globalWsName>, <delay>)
>>


CastExpr(ct, expr) ::= "((<ct>) <expr>)"


ContinueStat() ::= "continue"


DoStat(stat, expr) ::= <<
do{
  <stat; separator = ";\n">;
}while( <expr> )
>>


IfStat(expr, thenPart, elsePart) ::= <<
if( <expr> ) {
  <thenPart; separator = ";\n">;
}<if(elsePart)> else {
  <elsePart; separator = ";\n">;
}<endif>
>>


InvocationWithReturn(functionName, paramNumber, globalWorkspace, procParams, returnType) ::= <<
({
  <returnType> returnValue;
  functionName(<globalWorkspace><if(procParams)>, <procParams; separator =", "><endif>, &returnType);
  returnValue;
})
>>

InvocationNoReturn(functionName, paramNumber, workspace, procParams) ::= <<
<functionName>(<workspace><if(procParams)>, <procParams; separator =", "><endif>)
>>


InvocationPar(wordName, paramNumber, stackSize, parWs, index, globalWsName, procParams) ::= <<
word <wordName>[WORKSPACE_SIZE(<paramNumber>, <stackSize>)];
<parWs>[<index>] = LightProcInit(<globalWsName>, <wordName>, <paramNumber>, <stackSize>);
<if(procParams)><procParams; separator = ";\n">;<endif>
>>


ProcPar(paramWorkspaceName, processNumber, list) ::= <<
<! list is a list of strings alternating between the workspace form process n and the
   name of process n. Ex: { "ws1", "source", "ws2", "writer", "ws3", "doubleValue",... !>


ProcPar(<paramWorkspaceName>, <processNumber>, <list; separator = ", ">);
>>


ForStat(init, expr, incr, barriers, stats) ::= <<
for(<init; separator = ",">; <expr>; <incr>){
  <stats; separator = ";\n">;
}
>>


ReturnStat(expr) ::= "return<if(expr)> <expr><endif>"

ParBlock(stringStats, procPar, wsArrayName, wsArraySize) ::= <<
/*Parallel Block*/
{
  Workspace <wsArrayName>[<wsArraySize>];
  <stringStats; separator = "\n\n">
  <procPar>
}
>>


ProcTypeDecl(modifiers, returnType, name, formals, implement, body, workspace, last) ::= <<
<modifiers><returnType> <name>(Workspace <workspace><\\>
  <if(formals)>,<formals; separator = ", "><endif>)<implement>{
  <body; separator = ";\n">;<\\>

  <if(last)>

  shutDownLabel:
    Shutdown(<workspace>);<endif>
  <!TODO return type !>

}
>>

ParBlockProc(name, body, paramWorkspaceName, getParameters) ::= <<
<! Very similar to ProcTypeDecl but simplified for ParBlocks only. !>
void <name>(Workspace <paramWorkspaceName>){
  <if(getParameters)><getParameters; separator = ";\n">;<endif>
  <body>;

  return;
}
>>


LocalDecl(type, var, constant, channelPart) ::= <<
<! If this is channel it must be initialized! !>
<type> <var><if(channelPart)>MyChannel, *<var> = &<var>MyChannel; <channelPart><endif>
>>


SwitchLabel(constExpr) ::= "case <constExpr>:"

SwitchGroup(labels, stmts) ::= <<
  <labels; separator = "\n">
    <stmts; separator = ";\n">;
>>

SwitchStat(expr, switchGroups) ::= <<
switch( <expr> ){
  <switchGroups; separator = "\n">
}
>>


Ternary(expr, trueBranch, falseBranch) ::= "<expr> ? <trueBranch> : <falseBranch>"


UnaryPostExpr(expr, op) ::= "((<expr>) <op>)"


UnaryPreExpr(expr, op) ::= "(<op> (<expr>))"

WhileStat(expr, stat) ::= <<
while( <expr> ) {
  <stat; separator = ";\n">;
}
>>


Var(name, init) ::= "<name><if(init)> = <init><endif>"


CommentBar() ::= "/*======================================================================================*/"

ArrayStruct() ::= <<
typedef struct {
  void* array;
  int* dimensions;
  int numDim;
} ArrayStruct;
>>

CMainFunction(functionToCall, stackSize) ::= <<
int main(int argc, char** argv){
  int ccspResults;
  Workspace ws;

  /*Initialize CCSP*/
  ccspResults = ccsp_init();
  if(!ccspResults){
    printf("Error starting CCSP, exiting...\n");
    return 1;
  }

  ws = ProcAllocInitial(0, <stackSize>);
  ProcStartInitial(ws, <functionToCall>);
  return 0;
}
>>


Prototype(name, formals, workspace) ::= <<
void <name>(Workspace <workspace><if(formals)>, <formals; separator = ", "><endif>)
>>


ExternPrint(string, argumentList, argumentCount) ::= <<
ExternalCallN(printf, <argumentCount>, "<string>"<if(argumentList)>, <argumentList; separator = ", "><endif>)
>>


ProcParam(globalWsName, parWsName, index, paramNumber, param) ::= <<
ProcParam(<globalWsName>, <parWsName>[<index>], <paramNumber>, <param>)
>>


ProcGetParam(type, name, number, globalWsName) ::= <<
<type> <name> = ProcGetParam(<globalWsName>, <number>, <type>)
>>


ChanInit(globalWsName, channelName) ::= "ChanInit(<globalWsName>, <channelName>)"


CompoundStatement(param) ::= "<param>"


AltStat(altType, enableChannelList, waitType, disableChannelList,
        switchStatement) ::= <<
<! This is the main statement to create our AltCase, we have auxillary functions
   to fill the rest of it in... !>
/*Start of Alternative!*/
<altType>;

<enableChannelList; separator = ";\n">;

/*Do waiting here! */
<waitType>;

<disableChannelList; separator = ";\n">;

<switchStatement>

/*End of Alternative!*/
>>

NormalAltType(globalWsName) ::= "Alt(<globalWsName>)"
TimerAltType(globalWsName) ::= "TimerAlt(<globalWsName>)"


NormalWaitType(globalWsName) ::= "AltWait(<globalWsName>)"
TimerWaitType(globalWsName) ::= "TimerAltWait(<globalWsName>)"


AltEnableTimeout(globalWsName, number, time, name) ::= <<
<! This statement is funny as we actually need a variable to hold our time. !>
Time <name> = TimerRead(<globalWsName>) + <time>;
AltEnableTimer(<globalWsName>, <number>, <name>)
>>


AltEnableSkip(globalWsName, number) ::= "AltEnableSkip(<globalWsName>, <number>)"
AltEnableChannel(globalWsName, number, name) ::= "AltEnableChannel(<globalWsName>, <number>, <name>)"


AltDisableTimeout(globalWsName, number, name) ::= <<
AltDisableTimer(<globalWsName>, <number>, <name>)
>>


AltDisableChannel(globalWsName, number, name) ::= "AltDisableChannel(<globalWsName>, <number>, <name>)"
AltDisableSkip(globalWsName, number) ::= "AltDisableSkip(<globalWsName>, <number>)"


AltSwitch(altEnd, caseList) ::= <<
<! Our Switch Statement is a list of cases separated by breaks. !>
switch( <altEnd> ){
  <caseList; separator ="\n">
  default:
    printf("Reached default case of switch statement from Alt\n");
    printf("This should never happen... dying now X(\n");
    exit(1);
}
>>

AltCase(number, guardToDo, statementList) ::= <<
case <number>:
  <guardToDo>;
  <statementList; separator = ";\n">;
  break;
>>


AltEnd(globalWsName) ::= "AltEnd( <globalWsName> )"

SetArrayDimensions(name, num, expr) ::= "<name>.dimensions[<num>] = <expr>"

SetArraySize(name, size) ::= "<name>.numDim = <size>"

NewArray(globalWsName, name, type, numDim, size, dimensionList) ::= <<
<name>.array = (<type>*) MAlloc(<globalWsName>, MAX((sizeof(<type>) * <size>) / 4, 1));
<name>.numDim = <numDim>;
<name>.dimensions = (int*) MAlloc(<globalWsName>, (sizeof(int) * <numDim>) / 4);
<dimensionList; separator = ";\n">
>>

ArrayAccess(name, index, dim) ::= "(<index> * <name>.dimensions[<name>.numDim - 1 - <dim>])"

ParamDecl(type, name) ::= "<type> <name>"


WriteChannelMacro() ::= <<
#define WRITECHANNEL(functionName, type, expr, size) \\
void functionName(Workspace WP){ \\
  Channel** c = ProcGetParam(WP, 0, Channel**); \\
  type temp = (expr); \\
  ChanOut(WP, *c, &temp, size); \\
  return; \\
}
>>


ReadChannelMacro() ::= <<
#define READCHANNEL(functionName, type, size) \\
void functionName(Workspace WP){ \\
  type* x = ProcGetParam(WP, 0, type*); \\
  Channel** c = ProcGetParam(WP, 1, Channel**); \\
  ((*x) = ({ type tempX; \\
     ChanIn(WP, (*c), &tempX, size); \\
     tempX; \\
  })); \\
  return; \\
}
>>


writeChannel(functionName, type, expr, size) ::= <<
WRITECHANNEL(<functionName>, <type>, <expr>, <size>)
>>


readChannel(functionName, type, size) ::= <<
READCHANNEL(<functionName>, <type>, <size>)
>>
